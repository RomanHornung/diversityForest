else {
return(invisible(NULL))
}
}
if (is.infinite(length)) {
length <- -1
}
if (is.character(file) && missing(object)) {
object <- file
file <- TRUE
}
if (serialize && !file) {
object <- if ("nosharing" %in% names(formals(base::serialize)))
base::serialize(object, connection = NULL, ascii = ascii,
nosharing = TRUE)
else base::serialize(object, connection = NULL, ascii = ascii)
if (any(!is.na(pmatch(skip, "auto")))) {
if (ascii) {
skip <- which(object[1:30] == as.raw(10))[4]
}
else {
skip <- 14
}
}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenize()
roxygen2::roxygenize()
library(diversityForest)
## Prediction
train.idx <- sample(nrow(iris), 2/3 * nrow(iris))
iris.train <- iris[train.idx, ]
iris.test <- iris[-train.idx, ]
tuneres <- tunedivfor(formula = Species ~ ., data = iris.train)
require(diversityForest)
train.idx <- sample(nrow(iris), 2/3 * nrow(iris))
iris.train <- iris[train.idx, ]
iris.test <- iris[-train.idx, ]
tuneres <- tunedivfor(formula = Species ~ ., data = iris.train)
rg.iris <- divfor(Species ~ ., data = iris.train, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt)
pred.iris <- predict(rg.iris, data = iris.test)
table(iris.test$Species, pred.iris$predictions)
class(pred.iris)
roxygen2::roxygenise()
library("devtools")
find_rtools(T)
mydigest <- function (object, algo = c("md5", "sha1", "crc32", "sha256",
"sha512", "xxhash32", "xxhash64", "murmur32"), serialize = TRUE,
file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
raw = FALSE, seed = 0, errormode = c("stop", "warn", "silent"))
{
file.access <- R.utils::fileAccess
algo <- match.arg(algo)
errormode <- match.arg(errormode)
.errorhandler <- function(txt, obj = "", mode = "stop") {
if (mode == "stop") {
stop(txt, obj, call. = FALSE)
}
else if (mode == "warn") {
warning(txt, obj, call. = FALSE)
return(invisible(NA))
}
else {
return(invisible(NULL))
}
}
if (is.infinite(length)) {
length <- -1
}
if (is.character(file) && missing(object)) {
object <- file
file <- TRUE
}
if (serialize && !file) {
object <- if ("nosharing" %in% names(formals(base::serialize)))
base::serialize(object, connection = NULL, ascii = ascii,
nosharing = TRUE)
else base::serialize(object, connection = NULL, ascii = ascii)
if (any(!is.na(pmatch(skip, "auto")))) {
if (ascii) {
skip <- which(object[1:30] == as.raw(10))[4]
}
else {
skip <- 14
}
}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenise()
library("prioritylasso")
install.packages("prioritylasso")
library("prioritylasso")
set.seed(1234)
pl_bin1 <- prioritylasso(X = matrix(rnorm(50*500),50,500), Y = rbinom(50,1,0.5), family = "binomial",
type.measure = "auc", blocks = list(block1=1:13,block2=14:200, block3=201:500),
block1.penalization = TRUE, lambda.type = "lambda.min", standardize = FALSE,
nfolds = 5)
newdata_bin1 <- matrix(rnorm(30*500),30,500)
bin1_predict <- predict(object = pl_bin1, newdata = newdata_bin1, type = "response")
###
set.seed(1234)
pl_bin2 <- prioritylasso(X = matrix(rnorm(50*500),50,500), Y = rbinom(50,1,0.5), family = "binomial",
type.measure = "auc", blocks = list(block1=1:13,block2=14:200, block3=201:500),
block1.penalization = FALSE, lambda.type = "lambda.min", standardize = FALSE,
nfolds = 5)
newdata_bin2 <- matrix(rnorm(30*500),30,500)
bin2_predict <- predict(object = pl_bin2, newdata = newdata_bin2, type = "response")
###
class(bin2_predict)
dim(bin2_predict)
as.vector(bin2_predict)
bin2_predict
bin2_predict <- matrix(nrow=as.vector(bin2_predict), ncol=1, data=as.vector(bin2_predict))
bin2_predict <- predict(object = pl_bin2, newdata = newdata_bin2, type = "response")
bin2_predict
matrix(nrow=as.vector(bin2_predict), ncol=1)
bin2_predict
bin2_predict <- matrix(nrow=length(as.vector(bin2_predict)), ncol=1, data=as.vector(bin2_predict))
bin2_predict
rm(list=ls());gc()
# setwd("Z:/Projects/BlockForests/Package/blockForest/")
library("devtools")
find_rtools(T)
mydigest <- function (object, algo = c("md5", "sha1", "crc32", "sha256",
"sha512", "xxhash32", "xxhash64", "murmur32"), serialize = TRUE,
file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
raw = FALSE, seed = 0, errormode = c("stop", "warn", "silent"))
{
file.access <- R.utils::fileAccess
algo <- match.arg(algo)
errormode <- match.arg(errormode)
.errorhandler <- function(txt, obj = "", mode = "stop") {
if (mode == "stop") {
stop(txt, obj, call. = FALSE)
}
else if (mode == "warn") {
warning(txt, obj, call. = FALSE)
return(invisible(NA))
}
else {
return(invisible(NULL))
}
}
if (is.infinite(length)) {
length <- -1
}
if (is.character(file) && missing(object)) {
object <- file
file <- TRUE
}
if (serialize && !file) {
object <- if ("nosharing" %in% names(formals(base::serialize)))
base::serialize(object, connection = NULL, ascii = ascii,
nosharing = TRUE)
else base::serialize(object, connection = NULL, ascii = ascii)
if (any(!is.na(pmatch(skip, "auto")))) {
if (ascii) {
skip <- which(object[1:30] == as.raw(10))[4]
}
else {
skip <- 14
}
}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
require(diversityForest)
## Set seed to obtain reproducible results:
set.seed(1234)
## Diversity forest with default settings (NOT recommended)
divfor(Species ~ ., data = iris, num.trees = 20)
# NOTE: num.trees = 20 is specified too small for practical
# purposes, because the prediction performance of the resulting
# forest will be suboptimal!!
# In practice, num.trees = 500 (default value) or a
# larger number should be used.
## Diversity forest with specified values for nsplits and proptry (NOT recommended)
divfor(Species ~ ., data = iris, nsplits = 10, proptry = 0.4, num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
## Applying diversity forest after optimizing the values of nsplits and proptry (recommended)
tuneres <- tunedivfor(formula = Species ~ ., data = iris, num.trees.pre = 20)
# NOTE: num.trees.pre = 20 is specified too small for practical
# purposes, because the out-of-bag error estimates of the forests
# constructed during optimization will be much too variable!!
# In practice, num.trees.pre = 500 (default value) or a
# larger number should be used.
divfor(Species ~ ., data = iris, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
## Prediction
train.idx <- sample(nrow(iris), 2/3 * nrow(iris))
iris.train <- iris[train.idx, ]
iris.test <- iris[-train.idx, ]
tuneres <- tunedivfor(formula = Species ~ ., data = iris.train, num.trees.pre = 20)
# NOTE again: num.trees.pre = 20 is specified too small for practical purposes.
rg.iris <- divfor(Species ~ ., data = iris.train, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
pred.iris <- predict(rg.iris, data = iris.test)
table(iris.test$Species, pred.iris$predictions)
## Variable importance
rg.iris <- divfor(Species ~ ., data = iris, importance = "permutation", num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
rg.iris$variable.importance
train.idx <- sample(nrow(iris), 2/3 * nrow(iris))
iris.train <- iris[train.idx, ]
iris.test <- iris[-train.idx, ]
tuneres <- tunedivfor(formula = Species ~ ., data = iris.train, num.trees.pre = 20)
# NOTE again: num.trees.pre = 20 is specified too small for practical purposes.
rg.iris <- divfor(Species ~ ., data = iris.train, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
pred.iris <- predict(rg.iris, data = iris.test)
table(iris.test$Species, pred.iris$predictions)
train.idx <- sample(nrow(iris), 2/3 * nrow(iris))
iris.train <- iris[train.idx, ]
iris.test <- iris[-train.idx, ]
tuneres <- tunedivfor(formula = Species ~ ., data = iris.train, num.trees.pre = 20)
# NOTE again: num.trees.pre = 20 is specified too small for practical purposes.
rg.iris <- divfor(Species ~ ., data = iris.train, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
pred.iris <- predict(rg.iris, data = iris.test)
table(iris.test$Species, pred.iris$predictions)
train.idx <- sample(nrow(iris), 2/3 * nrow(iris))
iris.train <- iris[train.idx, ]
iris.test <- iris[-train.idx, ]
tuneres <- tunedivfor(formula = Species ~ ., data = iris.train, num.trees.pre = 200)
# NOTE again: num.trees.pre = 20 is specified too small for practical purposes.
rg.iris <- divfor(Species ~ ., data = iris.train, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 200)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
pred.iris <- predict(rg.iris, data = iris.test)
table(iris.test$Species, pred.iris$predictions)
7.5/12
(1 - 7.5/12)
0.375/0.625
9*0.375/0.625
library("devtools")
find_rtools(T)
mydigest <- function (object, algo = c("md5", "sha1", "crc32", "sha256",
"sha512", "xxhash32", "xxhash64", "murmur32"), serialize = TRUE,
file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
raw = FALSE, seed = 0, errormode = c("stop", "warn", "silent"))
{
file.access <- R.utils::fileAccess
algo <- match.arg(algo)
errormode <- match.arg(errormode)
.errorhandler <- function(txt, obj = "", mode = "stop") {
if (mode == "stop") {
stop(txt, obj, call. = FALSE)
}
else if (mode == "warn") {
warning(txt, obj, call. = FALSE)
return(invisible(NA))
}
else {
return(invisible(NULL))
}
}
if (is.infinite(length)) {
length <- -1
}
if (is.character(file) && missing(object)) {
object <- file
file <- TRUE
}
if (serialize && !file) {
object <- if ("nosharing" %in% names(formals(base::serialize)))
base::serialize(object, connection = NULL, ascii = ascii,
nosharing = TRUE)
else base::serialize(object, connection = NULL, ascii = ascii)
if (any(!is.na(pmatch(skip, "auto")))) {
if (ascii) {
skip <- which(object[1:30] == as.raw(10))[4]
}
else {
skip <- 14
}
}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenise()
roxygen2::roxygenise()
library("devtools")
find_rtools(T)
mydigest <- function (object, algo = c("md5", "sha1", "crc32", "sha256",
"sha512", "xxhash32", "xxhash64", "murmur32"), serialize = TRUE,
file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
raw = FALSE, seed = 0, errormode = c("stop", "warn", "silent"))
{
file.access <- R.utils::fileAccess
algo <- match.arg(algo)
errormode <- match.arg(errormode)
.errorhandler <- function(txt, obj = "", mode = "stop") {
if (mode == "stop") {
stop(txt, obj, call. = FALSE)
}
else if (mode == "warn") {
warning(txt, obj, call. = FALSE)
return(invisible(NA))
}
else {
return(invisible(NULL))
}
}
if (is.infinite(length)) {
length <- -1
}
if (is.character(file) && missing(object)) {
object <- file
file <- TRUE
}
if (serialize && !file) {
object <- if ("nosharing" %in% names(formals(base::serialize)))
base::serialize(object, connection = NULL, ascii = ascii,
nosharing = TRUE)
else base::serialize(object, connection = NULL, ascii = ascii)
if (any(!is.na(pmatch(skip, "auto")))) {
if (ascii) {
skip <- which(object[1:30] == as.raw(10))[4]
}
else {
skip <- 14
}
}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenise()
library("boot")
?boot
sqrt(0)
sqrt(-1)
?system
57000*0.9975
57000*(1-0.9975)
57000*(1-0.999)
## Survival forest
require(survival)
dim(veteran)
table(veteran$status)
veteran2 <- veteran
set.seed(1234)
ui <- sort(sample(1:nrow(veteran2), size=50))
veteran2 <- veteran2[ui,]
veteran2$celltype <- NULL
library("diversityForest")
ui <- divfor(Surv(time, status) ~ ., data = veteran2, num.trees = 1, verbose=FALSE, nsplits=30, replace=FALSE, sample.fraction=1)
