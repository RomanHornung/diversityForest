}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenise()
library(diversityForest)
# Check survival case:
## Survival forest
require(survival)
dim(veteran)
table(veteran$status)
veteran2 <- veteran
# set.seed(1234)
# ui <- sort(sample(1:nrow(veteran2), size=50))
# veteran2 <- veteran2[ui,]
veteran2$celltype <- NULL
library("diversityForest")
ui <- divfor(Surv(time, status) ~ ., data = veteran2, num.trees = 100, verbose=FALSE, nsplits=30)
ui <- divfor(Surv(time, status) ~ ., data = veteran, num.trees = 2, respect.unordered.factors = "order")
ui$prediction.error
ui <- divfor(Surv(time, status) ~ ., data = veteran, num.trees = 2)
ui$prediction.error
ui <- divfor(Surv(time, status) ~ ., data = veteran, num.trees = 2, respect.unordered.factors = "partition")
ui$prediction.error
?divfor
library("diversityForest")
## Set seed to obtain reproducible results:
set.seed(1234)
## Diversity forest with default settings (NOT recommended)
divfor(Species ~ ., data = iris, num.trees = 20)
# NOTE: num.trees = 20 is specified too small for practical
# purposes, because the prediction performance of the resulting
# forest will be suboptimal!!
# In practice, num.trees = 500 (default value) or a
# larger number should be used.
library("diversityForest")
## Set seed to obtain reproducible results:
set.seed(1234)
## Diversity forest with default settings (NOT recommended)
divfor(Species ~ ., data = iris, num.trees = 20)
getAnywhere("print.divfor")
# getAnywhere("print.divfor")
print.divfor <- function(x, ...) {
cat("divfor result\n\n")
cat("Call:\n", deparse(x$call), "\n\n")
cat("Type:                            ", x$treetype, "\n")
cat("Number of trees:                 ", x$num.trees, "\n")
cat("Sample size:                     ", x$num.samples, "\n")
cat("Number of independent variables: ", x$num.independent.variables, "\n")
cat("Nsplits:                         ", x$nsplits, "\n")
cat("Proptry:                         ", x$proptry, "\n")
cat("Target node size:                ", x$min.node.size, "\n")
cat("Variable importance mode:        ", x$importance.mode, "\n")
cat("Splitrule:                       ", x$splitrule, "\n")
if (x$treetype == "Survival") {
cat("Number of unique death times:    ", length(x$unique.death.times), "\n")
}
if (x$treetype == "Classification") {
cat("OOB prediction error:            ", sprintf("%1.2f %%", 100*x$prediction.error), "\n")
} else if (x$treetype == "Regression") {
cat("OOB prediction error (MSE):      ", x$prediction.error, "\n")
} else if (x$treetype == "Survival") {
cat("OOB prediction error (1-C):      ", x$prediction.error, "\n")
} else if (x$treetype == "Probability estimation") {
cat("OOB prediction error (Brier s.): ", x$prediction.error, "\n")
} else {
cat("OOB prediction error:            ", x$prediction.error, "\n")
}
if (x$treetype == "Regression") {
cat("R squared (OOB):                 ", x$r.squared, "\n")
}
}
environment(print.divfor) <- environment(divfor)
## Diversity forest with default settings (NOT recommended)
divfor(Species ~ ., data = iris, num.trees = 20)
## Diversity forest with default settings (NOT recommended)
ui<- divfor(Species ~ ., data = iris, num.trees = 20)$forest
class(ui)
## Prediction
train.idx <- sample(nrow(iris), 2/3 * nrow(iris))
iris.train <- iris[train.idx, ]
iris.test <- iris[-train.idx, ]
tuneres <- tunedivfor(formula = Species ~ ., data = iris.train, num.trees.pre = 20)
# NOTE again: num.trees.pre = 20 is specified too small for practical purposes.
rg.iris <- divfor(Species ~ ., data = iris.train, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
pred.iris <- predict(rg.iris, data = iris.test)
class(rg.iris)
class(pred.iris)
## Applying diversity forest after optimizing the values of nsplits and proptry (recommended)
tuneres <- tunedivfor(formula = Species ~ ., data = iris, num.trees.pre = 20)
class(tunres)
class(tuneres)
tuneres
library("devtools")
find_rtools(T)
mydigest <- function (object, algo = c("md5", "sha1", "crc32", "sha256",
"sha512", "xxhash32", "xxhash64", "murmur32"), serialize = TRUE,
file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
raw = FALSE, seed = 0, errormode = c("stop", "warn", "silent"))
{
file.access <- R.utils::fileAccess
algo <- match.arg(algo)
errormode <- match.arg(errormode)
.errorhandler <- function(txt, obj = "", mode = "stop") {
if (mode == "stop") {
stop(txt, obj, call. = FALSE)
}
else if (mode == "warn") {
warning(txt, obj, call. = FALSE)
return(invisible(NA))
}
else {
return(invisible(NULL))
}
}
if (is.infinite(length)) {
length <- -1
}
if (is.character(file) && missing(object)) {
object <- file
file <- TRUE
}
if (serialize && !file) {
object <- if ("nosharing" %in% names(formals(base::serialize)))
base::serialize(object, connection = NULL, ascii = ascii,
nosharing = TRUE)
else base::serialize(object, connection = NULL, ascii = ascii)
if (any(!is.na(pmatch(skip, "auto")))) {
if (ascii) {
skip <- which(object[1:30] == as.raw(10))[4]
}
else {
skip <- 14
}
}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenise()
library(diversityForest)
## Diversity forest with specified values for nsplits and proptry (NOT recommended)
divfor(Species ~ ., data = iris, nsplits = 10, proptry = 0.4, num.trees = 20)
## Applying diversity forest after optimizing the values of nsplits and proptry (recommended)
tuneres <- tunedivfor(formula = Species ~ ., data = iris, num.trees.pre = 20)
# NOTE: num.trees.pre = 20 is specified too small for practical
# purposes, because the out-of-bag error estimates of the forests
# constructed during optimization will be much too variable!!
# In practice, num.trees.pre = 500 (default value) or a
# larger number should be used.
divfor(Species ~ ., data = iris, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
?print.tunedivfor
?divfor
library("diversityForest")
## Set seed to obtain reproducible results:
set.seed(1234)
## Diversity forest with default settings (NOT recommended)
divfor(Species ~ ., data = iris, num.trees = 20)
# NOTE: num.trees = 20 is specified too small for practical
# purposes, because the prediction performance of the resulting
# forest will be suboptimal!!
# In practice, num.trees = 500 (default value) or a
# larger number should be used.
## Diversity forest with specified values for nsplits and proptry (NOT recommended)
divfor(Species ~ ., data = iris, nsplits = 10, proptry = 0.4, num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
## Applying diversity forest after optimizing the values of nsplits and proptry (recommended)
tuneres <- tunedivfor(formula = Species ~ ., data = iris, num.trees.pre = 20)
# NOTE: num.trees.pre = 20 is specified too small for practical
# purposes, because the out-of-bag er
tunres
tuneres
# Regression:
iris2 <- iris
iris2$Species <- NULL
iris2$Y <- rnorm(nrow(iris2))
divfor(Y ~ ., data = iris, num.trees = 20)
divfor(Y ~ ., data = iris2, num.trees = 20)
divfor(Y ~ ., data = iris2, num.trees = 20)
divfor(Y ~ ., data = iris2, num.trees = 20)
# Survival:
library("survival")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 20, respect.unordered.factors = "order")
length(unique(veteran$time))
length(unique(veteran$time[veteran$status==1]))
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 20, respect.unordered.factors = "order")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 20, respect.unordered.factors = "order")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 1000, respect.unordered.factors = "order")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 1000, respect.unordered.factors = "order")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 1000, respect.unordered.factors = "order")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 5000, respect.unordered.factors = "order")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 5000, respect.unordered.factors = "order")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 5000)
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 5000)
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 5000, respect.unordered.factors = "order")
divfor(Surv(time, status) ~ ., data = veteran, num.trees = 5000, respect.unordered.factors = "partition")
## Diversity forest with specified values for nsplits and proptry (NOT recommended)
divfor(Species ~ ., data = iris, nsplits = 10, proptry = 0.4, num.trees = 20)
## Applying diversity forest after optimizing the values of nsplits and proptry (recommended)
tuneres <- tunedivfor(formula = Species ~ ., data = iris, num.trees.pre = 20)
# NOTE: num.trees.pre = 20 is specified too small for practical
# purposes, because the out-of-bag error estimates of the forests
# constructed during optimization will be much too variable!!
# In practice, num.trees.pre = 500 (default value) or a
# larger number should be used.
divfor(Species ~ ., data = iris, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
## Variable importance
rg.iris <- divfor(Species ~ ., data = iris, importance = "permutation", num.trees = 20)
# NOTE again: num.trees = 20 is specified too small for practical purposes.
rg.iris$variable.importance
dim(veteran)
## Prediction
train.idx <- sample(nrow(veteran), 2/3 * nrow(veteran))
train.idx
tunedivfor
## Prediction
train.idx <- sample(nrow(veteran), 2/3 * nrow(veteran))
iris.train <- iris[train.idx, ]
iris.test <- iris[-train.idx, ]
tuneres <- tunedivfor(formula = Surv(time, status) ~ ., data = iris.train, num.trees.pre = 20)
## Prediction
train.idx <- sample(nrow(veteran), 2/3 * nrow(veteran))
iris.train <- veteran[train.idx, ]
iris.test <- veteran[-train.idx, ]
tuneres <- tunedivfor(formula = Surv(time, status) ~ ., data = iris.train, num.trees.pre = 20)
tunres
tuneres
## Prediction
train.idx <- sample(nrow(veteran), 2/3 * nrow(veteran))
iris.train <- veteran[train.idx, ]
iris.test <- veteran[-train.idx, ]
tuneres <- tunedivfor(formula = Surv(time, status) ~ ., data = iris.train, num.trees.pre = 20)
# NOTE again: num.trees.pre = 20 is specified too small for practical purposes.
rg.iris <- divfor(Surv(time, status) ~ ., data = iris.train, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
tuneres
## Prediction
train.idx <- sample(nrow(veteran), 2/3 * nrow(veteran))
iris.train <- veteran[train.idx, ]
iris.test <- veteran[-train.idx, ]
tuneres <- tunedivfor(formula = Surv(time, status) ~ ., data = iris.train, num.trees.pre = 20)
# NOTE again: num.trees.pre = 20 is specified too small for practical purposes.
rg.iris <- divfor(Surv(time, status) ~ ., data = iris.train, nsplits = tuneres$nsplitsopt,
proptry = tuneres$proptryopt, num.trees = 20)
tunres
tuneres
# NOTE again: num.trees = 20 is specified too small for practical purposes.
pred.iris <- predict(rg.iris, data = iris.test)
pred.iris
pred.iris$predictions
names(pred.iris)
pred.iris$survival
names(pred.iris)
pred.iris$chf
?tunedivfor
tuneres <- tunedivfor(formula = Surv(time, status) ~ ., data = veteran)
tuneres
names(tunere)
names(tuneres)
tuneres$ooberrs
plot(tuneres$ooberrs)
tuneres$tunegrid
ui <- tuneres$tunegrid
ui$err <- tuneres$ooberrs
ui
plot(ui$nsplitsgrid[ui$proptrygrid==0.05], ui$err[ui$proptrygrid==0.05], ylim=range(ui$err))
plot(ui$nsplitsgrid[ui$proptrygrid==0.05], ui$err[ui$proptrygrid==0.05], ylim=range(ui$err), ty="o")
lines(ui$nsplitsgrid[ui$proptrygrid==1], ui$err[ui$proptrygrid==1], ylim=range(ui$err), ty="o", col=2)
plot(ui$nsplitsgrid[ui$proptrygrid==0.05], ui$err[ui$proptrygrid==0.05], ylim=range(ui$err), ty="o", col=2)
lines(ui$nsplitsgrid[ui$proptrygrid==1], ui$err[ui$proptrygrid==1], ylim=range(ui$err), ty="o")
head(veteran)
sum(apply(veteran[,-c(3,4)], 2, function(x) length(unique(x))-1))
tuneres <- tunedivfor(formula = Surv(time, status) ~ ., data = veteran, num.trees.pre = 5000)
tuneres
ui <- tuneres$tunegrid
ui$err <- tuneres$ooberrs
plot(ui$nsplitsgrid[ui$proptrygrid==0.05], ui$err[ui$proptrygrid==0.05], ylim=range(ui$err), ty="o", col=2)
lines(ui$nsplitsgrid[ui$proptrygrid==1], ui$err[ui$proptrygrid==1], ylim=range(ui$err), ty="o")
tuneres <- tunedivfor(formula = Surv(time, status) ~ ., data = veteran, num.trees.pre = 20000)
tuneres
ui <- tuneres$tunegrid
ui$err <- tuneres$ooberrs
ui
plot(ui$nsplitsgrid[ui$proptrygrid==0.05], ui$err[ui$proptrygrid==0.05], ylim=range(ui$err), ty="o", col=2)
lines(ui$nsplitsgrid[ui$proptrygrid==1], ui$err[ui$proptrygrid==1], ylim=range(ui$err), ty="o")
plot(ui$nsplitsgrid[ui$proptrygrid==0.05], 1-ui$err[ui$proptrygrid==0.05], ylim=range(1-ui$err), ty="o", col=2)
lines(ui$nsplitsgrid[ui$proptrygrid==1], 1-ui$err[ui$proptrygrid==1], ylim=range(ui$err), ty="o")
library("devtools")
find_rtools(T)
mydigest <- function (object, algo = c("md5", "sha1", "crc32", "sha256",
"sha512", "xxhash32", "xxhash64", "murmur32"), serialize = TRUE,
file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
raw = FALSE, seed = 0, errormode = c("stop", "warn", "silent"))
{
file.access <- R.utils::fileAccess
algo <- match.arg(algo)
errormode <- match.arg(errormode)
.errorhandler <- function(txt, obj = "", mode = "stop") {
if (mode == "stop") {
stop(txt, obj, call. = FALSE)
}
else if (mode == "warn") {
warning(txt, obj, call. = FALSE)
return(invisible(NA))
}
else {
return(invisible(NULL))
}
}
if (is.infinite(length)) {
length <- -1
}
if (is.character(file) && missing(object)) {
object <- file
file <- TRUE
}
if (serialize && !file) {
object <- if ("nosharing" %in% names(formals(base::serialize)))
base::serialize(object, connection = NULL, ascii = ascii,
nosharing = TRUE)
else base::serialize(object, connection = NULL, ascii = ascii)
if (any(!is.na(pmatch(skip, "auto")))) {
if (ascii) {
skip <- which(object[1:30] == as.raw(10))[4]
}
else {
skip <- 14
}
}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenise()
library(diversityForest)
library("diversityForest")
?divfor
ui <- divfor(Surv(time, status) ~ ., data = veteran, num.trees = 200, respect.unordered.factors = "order", importance="permutation")
ui$variable.importance
plot(ui$variable.importance)
library("devtools")
find_rtools(T)
mydigest <- function (object, algo = c("md5", "sha1", "crc32", "sha256",
"sha512", "xxhash32", "xxhash64", "murmur32"), serialize = TRUE,
file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
raw = FALSE, seed = 0, errormode = c("stop", "warn", "silent"))
{
file.access <- R.utils::fileAccess
algo <- match.arg(algo)
errormode <- match.arg(errormode)
.errorhandler <- function(txt, obj = "", mode = "stop") {
if (mode == "stop") {
stop(txt, obj, call. = FALSE)
}
else if (mode == "warn") {
warning(txt, obj, call. = FALSE)
return(invisible(NA))
}
else {
return(invisible(NULL))
}
}
if (is.infinite(length)) {
length <- -1
}
if (is.character(file) && missing(object)) {
object <- file
file <- TRUE
}
if (serialize && !file) {
object <- if ("nosharing" %in% names(formals(base::serialize)))
base::serialize(object, connection = NULL, ascii = ascii,
nosharing = TRUE)
else base::serialize(object, connection = NULL, ascii = ascii)
if (any(!is.na(pmatch(skip, "auto")))) {
if (ascii) {
skip <- which(object[1:30] == as.raw(10))[4]
}
else {
skip <- 14
}
}
}
else if (!is.character(object) && !inherits(object, "raw")) {
return(.errorhandler(paste("Argument object must be of type character",
"or raw vector if serialize is FALSE"), mode = errormode))
}
if (file && !is.character(object))
return(.errorhandler("file=TRUE can only be used with a character object",
mode = errormode))
algoint <- switch(algo, md5 = 1, sha1 = 2, crc32 = 3, sha256 = 4,
sha512 = 5, xxhash32 = 6, xxhash64 = 7, murmur32 = 8)
if (file) {
algoint <- algoint + 100
object <- path.expand(object)
if (!file.exists(object)) {
return(.errorhandler("The file does not exist: ",
object, mode = errormode))
}
if (!isTRUE(!file.info(object)$isdir)) {
return(.errorhandler("The specified pathname is not a file: ",
object, mode = errormode))
}
if (file.access(object, 4)) {
return(.errorhandler("The specified file is not readable: ",
object, mode = errormode))
}
}
if (is.character(skip))
skip <- 0
val <- .Call(digest_impl, object, as.integer(algoint), as.integer(length),
as.integer(skip), as.integer(raw), as.integer(seed))
return(val)
}
library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
roxygen2::roxygenise()
